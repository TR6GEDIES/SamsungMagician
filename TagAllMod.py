# ---------------------------------------------------------------------------------
# é‘“å¡µå¹—è†‚è“¿få¯¥å¯¢è†ƒæš ç˜‰ç”…ç”ƒæ§Šæ§fç¢£ç¶®ç˜‹èŸç¢¯é¢±äº¦å°“ãi:i:i;;:;:: : :
# æ¾£å¹—å¶Œå¡¹å‚´å«©æ¦›ç•çš‹iè¢è€˜èšŒç´•æ¬’å„¼å·“è¥´è¸Ÿç¯fç½µfäº¦å°“ãi:i:i;;:;:: : :
# æ¼²è”­ç”ƒç¸Ÿè«›féº­çª¶è†©Iå¶®è–¤ç¯çˆ°æ›·æ¨”é»ãŒ¢Â´ã€€ã€€ï½€â…·è¸Ÿäº¦å°“ãi:i:i;;:;:: : :
# è”•æ¼“æ»¿fè•“èŸ‡è¸´fæ­™è‰‡è‰€è£²fçšé³«å·“è¥´éª¸ã€€ã€€ã€€ã€€ã€€è´’æ†Šäº¦å°“ãi:i:i;;:;:: : :
# æ¦Šç”ƒé½Šçˆ°fæ‡ˆæ©ˆç‡—æ®ªå¹¢ç·»Iç¿°å„‚æ¨”é»å¤¢'â€ã€€ ã€€ ,ï½¨å‚¾ç¯©ç¸’äº¦å°“ãi:i:i;;:;:: : :
# ç®‹èšèœšå£ŠåŠ‘è–¯iæš¹ç›¥çš‹è¢iè€˜èšŒç´•å¸â€²ã€€ã€€ã€€ é›«å¯¬Içˆ°æ›·fäº¦å°“ãi:i:i;;:;:: : :
# éŠ•é¢±éº¼å¯°ç¯è‚å¾‘æ‚—fç¯åš ç¯©iç¸’ç¸¡é½¢ã€€ã€€ ã€€ ã€€ â…§è¾¨fç¯Ié‹—fäº¦å°“ãi:i:i;;:; : : .
# ç¢¯èŸfç¶´éº¼è¾¨è¢fç’Ÿè¼¯é§²fè¿¯ç“²iè»Œå¸¶â€²ã€€ã€€ã€€ã€€ã€€`å®ˆIå–å­©få¥äº¦å°“ãi:i:i;;:;:: : : .
# ç¶®èª£æ’’fæ›·ç£”ç‘©å¾·få¹¢å„‚å„¼å·“è¥´ç·²â€²ã€€ ã€€ ã€€ ã€€ ã€€ `å®ˆæ¢iç£¬å»›iäº¦å°“ãi:i:i;;:;:: : : .
# æ…«å¯«å» å¾‘æ‚—ç·fç¯åš ç¯©Iç¸’ç¸¡å¤¢'Â´ã€€ã€€ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ `å®ˆå³½få¾‘æ‚—fäº¦å°“ãi:i:i;;:;:: : : .
# å»›åƒµIæ•¸ç•ç¯¥Iç†¾é¾èšŒç´•è¥´ç·²â€²ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€â€˜å®ˆç•çš‹å¼ŠiåŠäº¦å°“ãi:i:i;;:;:: : : .
# ç˜§iæ§²ç‘©fæ¢ç¯ç£¬æ›·fç“²è»Œæ„â€²ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€,gfæ¯¯ç¶´å¾‘æ‚—åš è¿©å¿™äº¦å°“ãi:i:i;;:;::
# è¥´ç½©ç¡¼fè‰‡è‰€è£²çšé³«è¥´é‘¿ç·²'ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ã€€ ã€€ ã€€ å¥ªå¯”få¦å‚€æµçŒ¯içˆ¾è¿©å¿™äº¦å°“ãi:i:
# æ¤ˆæ£˜æ–çŠ€è€‹çµçµ²çµ¨ç·²â€²ã€€ã€€ã€€ã€€ã€€ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ â€'ç½¨æ‚³èªfè’‚æ¸¹å¹‡få»è¿©å¿™iäº¦å°“ã
# æ½æ¨—Iç˜§å¾·å¹¢iå„‚å·“ç·²â€²ã€€ã€€ã€€ã€€ã€€ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ ã€€ rã¡â„¡ã€Ÿâ€'ç½¨æ¤è£‚æ»…æ¥”æ»„æ„¼æ„°è¿©å¿™äº¦
# ç¿¦iç£…è‰˜æº²Iæ¦å„¼å·“ç™»zzz zzzãœãœï½§gã€€ ã€€ ç·² gã€€ ã€€ ç”¯é«”içˆºã‚ï½¡, â€'ç½¨ç¥ç„œæ¯³å¾­iåµ¬å¡°æ…çµ²
# æ¢ç¯ç£¬fæ›·è¿¯iç“²è»Œfè¥´æš¹ ç”¯å¹—ç·² ,fi'ã€€ã€€ ç·²',çºœï½¡ã€€ã€€è´’iç¶Ÿç¢•ç¢šçˆºã‚ï½¡ â€'ç½¨çš´ç™¼å‚²äº‚Ié»¹é±
# ç·æ„¾æ…Šåµ¬åµ¯æ¬’å„¼å·“è¥´é©« éœ¤Iç·² ,ç·²ã€€ã€€ ï¼‚,çºœç©ã€€ã€€ç”¯çµ›è·¨é£©ié«¢é¦³çˆºã‚ï½¡`'ç­‰èª„Iç­´ç¢ŒIç•·
# ç½©ç¡¼Iè’»ç­µç¡ºè‰‡è‰€iè£²çšäº€ ç¯³'â€™,ç·²ã€€ã€€gäº€ â…¦ilé½¢ã€€ã€€è´’ç½©ç¡¼iè‰‡è‰€è£²çšé³«çˆºé é£­è›¸Iè£˜è£”
# æ¤ˆfæ£˜è±¢è·«è·ªIè¡™çµçµ²çµ¨içˆºiãœiâ…£ ã€€ ,ç·²iäº€ â…¦éˆ,ã€€ã€€ç”¯å‚…å–©Iæµæšæƒ¹å±¡çµç—™æ£æ•è£”ç­´æ•¢
# é ¬iéè¤‚fè·«è©¹é›‹é«¢iæ›·è¿¯ç“²è»Œéœ¤ ã€€ ,ç·²è”­ç© â…¦ç© ã€€ è®æ¤ˆiæ£˜è²…fæ–çŠ€è€‹fçµçµ²è§šfè¦ƒé»¹é»
# è¥´è”½æˆ®è²²è‰€èˆ…Iè‚…è‚„è‚†æ§¿fè“â…§ ã€€ ç·²$æ…šIç©,ç–Šç©ã€€ ç”¯èªç¢¾fé‹—è¼œé fèª¹è‡§é‹©fè¤‚è·«è©¹ié›‹
# ---------------------------------------------------------------------------------
# ğŸŒ This project was created https://t.me/SamsungMagician
# âš ï¸ Licensed under the GNU AGPLv3.
# ğŸ’¢ The owner of this script does not have any responsibility or intellectual property rights in relation to this script.
# ---------------------------------------------------------------------------------
# Name: TagAllMod
# Author: https://t.me/SamsungMagician
# ---------------------------------------------------------------------------------

__version__ = (1, 0, 0)

# meta developer: @SamsungMagician

import asyncio
import contextlib
import logging
import random

from aiogram import Bot
from hikkatl.tl.functions.channels import InviteToChannelRequest
from hikkatl.tl.types import Message

from .. import loader, utils
from ..inline.types import InlineCall

logger = logging.getLogger(__name__)


class StopEvent:
    def __init__(self):
        self.state = True

    def stop(self):
        self.state = False


@loader.tds
class TagAllMod(loader.Module):
    """Ğ¤Ğ¾Ñ€Ğº, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ TagAll Ğ¸ TagAll_Bot Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ² Ğ¾Ğ´Ğ¸Ğ½"""

    strings = {
        "name": "TagAllMod",
        "bot_error": "ğŸš« <b>Unable to invite inline bot to chat</b>",
        "_cfg_doc_default_message": "Default message of mentions",
        "_cfg_doc_delete": "Delete messages after tagging",
        "_cfg_doc_use_bot": "Use inline bot to tag people",
        "_cfg_doc_timeout": "What time interval to sleep between each tag message",
        "_cfg_doc_silent": "Do not send message with cancel button",
        "_cfg_doc_cycle_tagging": (
            "Tag all participants over and over again until you stop the script using"
            " the button in the message"
        ),
        "_cfg_doc_cycle_delay": "Delay between each cycle of tagging in seconds",
        "gathering": "ğŸ§šâ€â™€ï¸ <b>Calling participants of this chat...</b>",
        "cancel": "ğŸš« Cancel",
        "cancelled": "ğŸ§šâ€â™€ï¸ <b>TagAll cancelled!</b>",
        "channel": "Support the developer ğŸ’«",
        "welcome": (
            "ğŸ– <i>Greetings, you have started the module installation. <b>Â«TagAllModÂ»</b></i>"
            "\n\nğŸ¤ <i>Thank you for the installation</i>"
            "\n\nâš™ï¸ <i>Create by <code>@SamsungMagician</code></i>"),
    }

    strings_ru = {
        "bot_error": "ğŸš« <b>ĞĞµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¾ÑÑŒ Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ° Ğ² Ñ‡Ğ°Ñ‚</b>",
        "_cls_doc": (
            "ĞÑ‚Ğ¼ĞµÑ‡Ğ°ĞµÑ‚ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‡Ğ°Ñ‚Ğ°, Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ğ¸Ğ½Ğ»Ğ°Ğ¹Ğ½ Ğ±Ğ¾Ñ‚ Ğ¸Ğ»Ğ¸ ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¼"
            " Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ¼"
        ),
        "_cfg_doc_default_message": "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚ĞµĞ³Ğ¾Ğ²",
        "_cfg_doc_delete": "Ğ£Ğ´Ğ°Ğ»ÑÑ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ÑĞ»Ğµ Ñ‚ĞµĞ³Ğ°",
        "_cfg_doc_use_bot": "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ Ñ‚ĞµĞ³Ğ¾Ğ²",
        "_cfg_doc_timeout": "Ğ’Ñ€ĞµĞ¼Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ñ Ñ‚ĞµĞ³Ğ°Ğ¼Ğ¸",
        "_cfg_doc_silent": "ĞĞµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹",
        "_cfg_doc_cycle_tagging": (
            "Ğ¢ĞµĞ³Ğ°Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² ÑĞ½Ğ¾Ğ²Ğ° Ğ¸ ÑĞ½Ğ¾Ğ²Ğ°, Ğ¿Ğ¾ĞºĞ° Ğ²Ñ‹ Ğ½Ğµ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ ÑĞºÑ€Ğ¸Ğ¿Ñ‚,"
            " Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ² ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¸"
        ),
        "_cfg_doc_cycle_delay": "Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ†Ğ¸ĞºĞ»Ğ°Ğ¼Ğ¸ Ñ‚ĞµĞ³Ğ¾Ğ² Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…",
        "gathering": "<b>Ğ¡Ğ±Ğ¾Ñ€ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‡Ğ°Ñ‚Ğ°...</b>",
        "cancel": "ğŸš« ĞÑ‚Ğ¼ĞµĞ½Ğ°",
        "cancelled": "ï¸ <b>Ğ¡Ğ±Ğ¾Ñ€ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½!</b>",
        "channel": "ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ° ğŸ’«",
        "welcome": (
            "ğŸ– <i>ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑ, Ñ‚Ñ‹ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ğ» ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ <b>Â«TagAllModÂ»</b></i>"
            "\n\nğŸ¤ <i>Ğ‘Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€Ñ Ğ·Ğ° ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ</i>"
            "\n\nâš™ï¸ <i>Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ by <code>@SamsungMagician</code></i>"),
    }

    strings_de = {
        "bot_error": "ğŸš« <b>Einladung des Inline-Bots in den Chat fehlgeschlagen</b>",
        "_cfg_doc_default_message": "Standardnachricht fÃ¼r ErwÃ¤hnungen",
        "_cfg_doc_delete": "Nachrichten nach ErwÃ¤hnung lÃ¶schen",
        "_cfg_doc_use_bot": "Inline-Bot verwenden, um Leute zu erwÃ¤hnen",
        "_cfg_doc_timeout": (
            "Zeitintervall, in dem zwischen den ErwÃ¤hnungen gewartet wird"
        ),
        "_cfg_doc_silent": "Nachricht ohne Abbrechen-Button senden",
        "_cfg_doc_cycle_tagging": (
            "Alle Teilnehmer immer wieder erwÃ¤hnen, bis du das Skript mit der"
            " SchaltflÃ¤che in der Nachricht stoppst"
        ),
        "_cfg_doc_cycle_delay": (
            "VerzÃ¶gerung zwischen jedem Zyklus der ErwÃ¤hnung in Sekunden"
        ),
        "gathering": "ğŸ§šâ€â™€ï¸ <b>ErwÃ¤hne Teilnehmer dieses Chats...</b>",
        "cancel": "ğŸš« Abbrechen",
        "cancelled": "ğŸ§šâ€â™€ï¸ <b>TagAll abgebrochen!</b>",
        "channel": "UnterstÃ¼tze die Entwickler ğŸ’«",
        "welcome": (
            "ğŸ– <i>Hallo, du hast die Installation des Moduls gestartet <b>Â«TagAllModÂ»</b></i>"
            "\n\nğŸ¤ <i>Danke fÃ¼r die Installation</i>"
            "\n\nâš™ï¸ <i>Geschaffen by <code>@SamsungMagician</code></i>"),
    }

    strings_tr = {
        "bot_error": "ğŸš« <b>Inline botunu sohbete davet edilemedi</b>",
        "_cfg_doc_default_message": "VarsayÄ±lan etiket mesajÄ±",
        "_cfg_doc_delete": "Etiketledikten sonra mesajlarÄ± sil",
        "_cfg_doc_use_bot": "Ä°nsanlarÄ± etiketlemek iÃ§in inline botu kullan",
        "_cfg_doc_timeout": "Her etiket mesajÄ± arasÄ±nda ne kadar bekleneceÄŸi",
        "_cfg_doc_silent": "Ä°ptal dÃ¼ÄŸmesi olmadan mesaj gÃ¶nderme",
        "_cfg_doc_cycle_tagging": (
            "Mesajdaki dÃ¼ÄŸmeyi kullanarak betiÄŸi durdurana kadar tÃ¼m katÄ±lÄ±mcÄ±larÄ±"
            " tekrar tekrar etiketle"
        ),
        "_cfg_doc_cycle_delay": "Etiketleme dÃ¶ngÃ¼sÃ¼ arasÄ±ndaki gecikme sÃ¼resi (saniye)",
        "gathering": "ğŸ§šâ€â™€ï¸ <b>Bu sohbetteki katÄ±lÄ±mcÄ±larÄ± Ã§aÄŸÄ±rÄ±yorum...</b>",
        "cancel": "ğŸš« Ä°ptal",
        "cancelled": "ğŸ§šâ€â™€ï¸ <b>TagAll iptal edildi!</b>",
        "channel": "GeliÅŸtirici destek ğŸ’«",
        "welcome": (
            "ğŸ– <i>Selamlar, modÃ¼l kurulumunu baÅŸlattÄ±nÄ±z <b>Â«TagAllModÂ»</b></i>"
            "\n\nğŸ¤ <i>Kurulum iÃ§in teÅŸekkÃ¼r ederim</i>"
            "\n\nâš™ï¸ <i>OluÅŸturuldu by <code>@SamsungMagician</code></i>"),
    }

    strings_uz = {
        "bot_error": (
            "ğŸš« <b>Inline botni chatga taklif qilish muvaffaqiyatsiz boâ€˜ldi</b>"
        ),
        "_cfg_doc_default_message": "Odatiy etiket xabari",
        "_cfg_doc_delete": "Etiketdan soâ€˜ng xabarlarni oâ€˜chirish",
        "_cfg_doc_use_bot": "Odamlarni etiketlash uchun inline botdan foydalanish",
        "_cfg_doc_timeout": "Har bir etiket xabari orasida nechta kutish kerak",
        "_cfg_doc_silent": "Bekor tugmasi olmadan xabar joâ€˜natish",
        "_cfg_doc_cycle_tagging": (
            "Xabar boâ€˜yicha tugmani ishlatib, skriptni toâ€˜xtatguncha barcha"
            " qatnashuvchilarni qayta-qayta etiketlash"
        ),
        "_cfg_doc_cycle_delay": "Har bir etiketlash tsikli orasida gecikma (soniya)",
        "gathering": "ğŸ§šâ€â™€ï¸ <b>Ushbu chatta qatnashganlarni chaqiraman...</b>",
        "cancel": "ğŸš« Bekor qilish",
        "cancelled": "ğŸ§šâ€â™€ï¸ <b>TagAll bekor qilindi!</b>",
        "channel": "Ishlab chiquvchini qo'llab-quvvatlang ğŸ’«",
        "welcome": (
            "ğŸ– <i>Salom, siz modulni o'rnatishni boshladingiz <b>Â«TagAllModÂ»</b></i>"
            "\n\nğŸ¤ <i>O'rnatish uchun rahmat</i>"
            "\n\nâš™ï¸ <i>Yaratilgan by <code>@SamsungMagician</code></i>"),
    }

    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "default_message",
                "@all",
                lambda: self.strings("_cfg_doc_default_message"),
            ),
            loader.ConfigValue(
                "delete",
                False,
                lambda: self.strings("_cfg_doc_delete"),
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "use_bot",
                False,
                lambda: self.strings("_cfg_doc_use_bot"),
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "timeout",
                0.1,
                lambda: self.strings("_cfg_doc_timeout"),
                validator=loader.validators.Float(minimum=0),
            ),
            loader.ConfigValue(
                "silent",
                False,
                lambda: self.strings("_cfg_doc_silent"),
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "cycle_tagging",
                False,
                lambda: self.strings("_cfg_cycle_tagging"),
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "cycle_delay",
                0,
                lambda: self.strings("_cfg_cycle_delay"),
                validator=loader.validators.Integer(minimum=0),
            ),
        )


    async def on_dlmod(self):
        await self.inline.bot.send_photo(
            self._client._self_id,
            "https://pomf2.lain.la/f/n93g4nzd.jpg",
            caption=self.strings("welcome"),
        )

    async def client_ready(self, client, db) -> None:
        self.db = db
        self.client = client

        logger.info("ĞœĞ¾Ğ´ÑƒĞ»ÑŒ TagAllMod ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ!")

        await self.request_join(
            "@SamsungMagicianModules",
            self.strings['channel'],
        )

    async def cancel(self, call: InlineCall, event: StopEvent):
        event.stop()
        await call.answer(self.strings("cancel"))

    @loader.command(
        groups=True,
        ru_doc="[Ñ‚ĞµĞºÑÑ‚] - Ğ¾Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‡Ğ°Ñ‚Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ğ±Ğ¾Ñ‚Ğ°",
        de_doc="[Text] - Alle Chatteilnehmer erwÃ¤hnen",
        tr_doc="[metin] - Sohbet katÄ±lÄ±mcÄ±larÄ±nÄ± etiketle",
        uz_doc="[matn] - Chat qatnashuvchilarini tegish",
    )
    async def tq(self, message: Message):
        """[Ñ‚ĞµĞºÑÑ‚] - Ğ¾Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‡Ğ°Ñ‚Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ğ±Ğ¾Ñ‚Ğ°"""
        args = utils.get_args_raw(message)
        if message.out:
            await message.delete()

        if self.config["use_bot"]:
            try:
                await self._client(
                    InviteToChannelRequest(message.peer_id, [self.inline.bot_username])
                )
            except Exception:
                await utils.answer(message, self.strings("bot_error"))
                return

            with contextlib.suppress(Exception):
                Bot.set_instance(self.inline.bot)

            chat_id = int(f"-100{utils.get_chat_id(message)}")
        else:
            chat_id = utils.get_chat_id(message)

        event = StopEvent()

        if not self.config["silent"]:
            cancel = await self.inline.form(
                message=message,
                text=self.strings("gathering"),
                reply_markup={
                    "text": self.strings("cancel"),
                    "callback": self.cancel,
                    "args": (event,),
                },
            )

        first, br = True, False
        while True if self.config["cycle_tagging"] else first:
            for chunk in utils.chunks(
                [
                    f'<a href="tg://user?id={user.id}">\xad</a>'
                    async for user in self._client.iter_participants(message.peer_id)
                ],
                5,
            ):
                m = await (
                    self.inline.bot.send_message
                    if self.config["use_bot"]
                    else self._client.send_message
                )(
                    chat_id,
                    utils.escape_html(args or self.config["default_message"])
                    + "\xad".join(chunk),
                )

                if self.config["delete"]:
                    with contextlib.suppress(Exception):
                        await m.delete()

                async def _task():
                    nonlocal event, cancel
                    if not self.config["silent"]:
                        return

                    while True:
                        if not event.state:
                            await cancel.edit(self.strings("cancelled"))
                            return

                        await asyncio.sleep(0.1)

                task = asyncio.ensure_future(_task())
                await asyncio.sleep(self.config["timeout"])
                task.cancel()
                if not event.state:
                    br = True
                    break

            if br:
                break

            first = False
            if self.config["cycle_tagging"]:
                await asyncio.sleep(self.config["cycle_delay"])

        if cancel is not None:
            try:
                await cancel.delete()
            except AttributeError:
                try:
                    await cancel.edit(self.strings("cancelled"))
                except:
                    pass
            except Exception as e:
                logger.warning(f"[TagAllMod] Error deleting inline message: {e}")


    async def tagcmd(self, message):
        """.tag <@> <text> - Ğ¾Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ñ‡Ğ°Ñ‚Ğµ"""
        args = utils.get_args_raw(message).split(" ")
        reply = await message.get_reply_message()
        user, tag = None, None
        try:
            if len(args) == 1:
                args = utils.get_args_raw(message)
                user = await message.client.get_entity(
                    args if not args.isnumeric() else int(args)
                )
                tag = "á… "
            elif len(args) >= 2:
                user = await message.client.get_entity(
                    args[0] if not args[0].isnumeric() else int(args[0])
                )
                tag = utils.get_args_raw(message).split(" ", 1)[1]
        except:
            return await message.edit("Failed to find a user.")
        await message.delete()
        await message.client.send_message(
            message.to_id,
            f'{tag} <a href="tg://user?id={user.id}">\u2060</a>',
            reply_to=reply.id if reply else None,
        )


    async def tagallcmd(self, message):
        """.tagall <Ñ‚ĞµĞºÑÑ‚> - Ğ¾Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ² Ñ‡Ğ°Ñ‚Ğ°"""
        args = utils.get_args_raw(message)
        tag = args or "á… "
        await message.delete()
        tags = []
        async for user in message.client.iter_participants(message.to_id):
            tags.append(f"<a href='tg://user?id={user.id}'>\u2060</a>")
        chunkss = list(chunks(tags, 5))
        random.shuffle(chunkss)
        for chunk in chunkss:
            await message.client.send_message(message.to_id, tag + "\u2060".join(chunk))


def chunks(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i : i + n]

